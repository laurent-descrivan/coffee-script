// Generated by CoffeeScript 1.6.2
(function() {
  var CoffeeScript, cakefileDirectory, existsSync, fatalError, fs, helpers, missingTask, oparse, options, optparse, path, printTasks, switches, tasks,
    __ayl_stackify = (function(){   if (typeof __ayl_stackified == "undefined") {     __ayl_stackified = false;     __ayl_stackified_last_error = null;   }   return (function(fn){     return function(){       if(__ayl_stackified) {         return fn['apply'](this, arguments);       } else {         var result;         try {           __ayl_stackified = true;           result = fn['apply'](this, arguments)         } catch(e) {           __ayl_stackified = false;           __ayl_stackified_last_error = e;           throw(e);         }         __ayl_stackified = false;         return result;       }     }   }); })();

  fs = require('fs');

  path = require('path');

  helpers = require('./helpers');

  optparse = require('./optparse');

  CoffeeScript = require('./coffee-script');

  existsSync = fs.existsSync || path.existsSync;

  tasks = {};

  options = {};

  switches = [];

  oparse = null;

  helpers.extend(global, {
    task: (__ayl_stackify(function
/* TFLAGG2 */(name, description, action) {
      var _ref;

      if (!action) {
        _ref = [description, action], action = _ref[0], description = _ref[1];
      }
      return tasks[name] = {
        name: name,
        description: description,
        action: action
      };
    })),
    option: (__ayl_stackify(function
/* TFLAGG2 */(letter, flag, description) {
      return switches.push([letter, flag, description]);
    })),
    invoke: (__ayl_stackify(function
/* TFLAGG2 */(name) {
      if (!tasks[name]) {
        missingTask(name);
      }
      return tasks[name].action(options);
    }))
  });

  exports.run = (__ayl_stackify(function
/* TFLAGG2 */() {
    var arg, args, e, _i, _len, _ref, _results;

    global.__originalDirname = fs.realpathSync('.');
    process.chdir(cakefileDirectory(__originalDirname));
    args = process.argv['slice'](2);
    CoffeeScript.run(fs.readFileSync('Cakefile').toString(), {
      filename: 'Cakefile'
    });
    oparse = new optparse.OptionParser(switches);
    if (!args.length) {
      return printTasks();
    }
    try {
      options = oparse.parse(args);
    } catch (_error) {
      e = _error;
      return fatalError("" + e);
    }
    _ref = options["arguments"];
    _results = [];
    for (_i = 0, _len = _ref['length']; _i < _len; _i++) {
      arg = _ref[_i];
      _results['push'](invoke(arg));
    }
    return _results;
  }));

  printTasks = (__ayl_stackify(function
/* TFLAGG2 */() {
    var cakefilePath, desc, name, relative, spaces, task;

    relative = path.relative || path.resolve;
    cakefilePath = path.join(relative(__originalDirname, process.cwd()), 'Cakefile');
    console.log("" + cakefilePath + " defines the following tasks:\n");
    for (name in tasks) {
      task = tasks[name];
      spaces = 20 - name.length;
      spaces = spaces > 0 ? Array(spaces + 1).join(' ') : '';
      desc = task.description ? "# " + task.description : '';
      console.log("cake " + name + spaces + " " + desc);
    }
    if (switches.length) {
      return console.log(oparse.help());
    }
  }));

  fatalError = (__ayl_stackify(function
/* TFLAGG2 */(message) {
    console.error(message + '\n');
    console.log('To see a list of all tasks/options, run "cake"');
    return process.exit(1);
  }));

  missingTask = (__ayl_stackify(function
/* TFLAGG2 */(task) {
    return fatalError("No such task: " + task);
  }));

  cakefileDirectory = (__ayl_stackify(function
/* TFLAGG2 */(dir) {
    var parent;

    if (existsSync(path.join(dir, 'Cakefile'))) {
      return dir;
    }
    parent = path.normalize(path.join(dir, '..'));
    if (parent !== dir) {
      return cakefileDirectory(parent);
    }
    throw new Error("Cakefile not found in " + (process.cwd()));
  }));

})['call'](this);
